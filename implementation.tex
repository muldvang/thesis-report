%chktex-file 44

\chapter{Implementation}
\label{cha:implementation}

This chapter describes the important aspects of the implementation.  As this
thesis is intended as being an extension of the work made by zipHMMlib made by
\citet{sand2013ziphmmlib}, from now on called the original library, the code
itself is also an extension of the library.  By the work made in this thesis
the library has been extended to include an efficient Viterbi implementation
and a indexed posterior decoding implementation exploiting repetitions, as well
as a posterior decoding implementation that does not exploit repetitions.

As zipHMMlib is written in C++ the additions made in this thesis have also been
written in C++.  This code can be downloaded from
\url{users-cs.au.dk/muldvang}.  \fxerror{URL here.} The build procedure has not
changed, so for instructions on how to build the project see
\url{github.com/mailund/ziphmm}.

\section{Description of the Implementation}

In the original library the main class of the library was the
\texttt{Forwarder} class.  This class has been renamed to \texttt{HMM\_Suite}.
Like before the class is responsible for preprocessing sequences, reading and
writing these from and to the disk, and for executing the forward, backward,
Viterbi and posterior decoding algorithms.  The library supports reading in
multiple sequences from a folder.  In the original library the sum of the
likelihoods for each sequence is returned.  This has also been implemented for
the Viterbi algorithm.  However, it is not currently supported to read in
multiple sequences if either the forward or backward tables are requested and
neither if the Viterbi path or posterior decoding is requested.

For matrix multiplications a BLAS framework is used to make these as efficient
as posible.  For the max times matrix multplication and addition simple nested
for loops are used as BLAS does not support these operations.

\section{Usage}

In the following three sections the usage of the Viterbi algorithm, the
posterior decoding algorithm, and the indexed posterior decoding algorithm from
within C++ is described. Lastly the programs added to the library are
discussed.

\subsection{Viterbi}

In listing~\ref{lst:c++-example} an example of C++ program that uses zipHMMlib
to compute the Viterbi decoding.

\begin{listing}
\begin{minted}[fontsize=\footnotesize]{C++}
#include "hmm_io.hpp"
#include "hmm_suite.hpp"

int main() {
    // Read input.
    zipHMM::HMMSuite h;
    size_t alphabet_size = 2;
    size_t min_num_of_evals = 1;
    size_t no_states = 2;
    h.read_seq("test.seq", alphabet_size, no_states, min_num_of_evals);

    // Save for future runs.
    h.write_to_directory("some_dir");

    // Read HMM.
    zipHMM::Matrix pi, A, B;
    zipHMM::read_HMM(pi, A, B, "test.hmm");

    // Run Viterbi.
    bool memory_save = false;
    std::vector<unsigned> viterbi_path;
    double likelihood = h.viterbi(pi, A, B, memory_save, viterbi_path);

    // Print result to stdout.
    std::cout << "Likelihood: " << likelihood << std::endl
              << "Path: ";
    for (std::vector<unsigned>::const_iterator it = viterbi_path.begin();
         it != viterbi_path.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    exit(0);
}
\end{minted}
\caption{C++ example}
\label{lst:c++-example}
\end{listing}

The \texttt{HMM\_Suite.read\_seq(\dots)} reads a sequence from a file. The user
has to specify the alphabet size, since the sequence may not contain all
symbols from the alphabet. Furthermore the user specifies that number of states
in the model $N_{\min}$ that will be used later and the number of executions
$e$ of the Viterbi algorithm as discussed in
section~\ref{sec:compr-stopp-crit}.

If the compressed sequence will be reused later by another program it is saved
to the disk by \texttt{HMM\_Suite.write\_to\_directory(\dots)}. It may then be
loaded using \texttt{HMM\_Suite.read\_from\_directory(\dots)}.

\texttt{HMM\_Suite.read\_HMM(\dots)} simply reads an HMM specification from a
file.

\texttt{HMM\_Suite.viterbi(\dots)} runs the Viterbi algorithm. A boolean
\texttt{memory\_save} may be specified to choose whether to save memory or not
as discussed in section~\ref{sec:backtracking-1}. If the paramter is not
specified the algorithm defaults to using memory saving. If the parameter
\texttt{viterbi\_path} is provided the algorithm will backtrack to obtain the
Viterbi path. If it is omitted only the likelihood of the most likely path is
computed.

\subsection{Posterior Decoding}

As described in section~\ref{sec:probl-expl-repet}, exploiting repetitions will
cannot speed up the execution of the posterior decoding algorithm. It may still
be faster, due matrix multiplications being faster than the classical
approach. The implementation find a posterior decoding of the same length as
the compressed sequence. Hence, to find the posterior decoding of the original
observation sequence $Y_{1:T}$, compressed should be disabled. This may be done by
specifying $e = 0$ when reading the sequence using
\texttt{HMM\_Suite.read\_seq(\dots)}.

The \texttt{HMM\_Suite.posterior\_decoding(\dots)} is a bit simpler than the
Viterbi method and takes as parameters the matrices $\pi, A$, and $B$ and a
vector in which the posterior decoding is saved.

\subsection{Indexed Posterior Decoding}

For the indexed posterior decoding compression may be enabled. The
\texttt{HMM\_Suite::indexed\_posterior\_decoding(\dots)} takes as paramters the
matrices $\pi, A$, and $B$, the indices $i$ and $j$ and a reference to a vector
where the indexed posterior decoding is saved.

\subsection{Programs}

\fxerror{Create programs with similar parameters to the forward program and
  describe how to use them!.}

\fxnote{How to use the Python and R bindings.}
%%% Local Variables:
%%% mode: latex
%%% TeX-command-extra-options: "-shell-escape"
%%% TeX-master: "master"
%%% End:
