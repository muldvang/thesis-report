%chktex-file 44

\chapter{Implementation}
\label{cha:implementation}

This chapter describes the important aspects of the implementation.  As this
thesis is intended to be an extension of zipHMMlib by
\citet{sand2013ziphmmlib}, from now on called the original library, the code
itself is also an extension of the library code.  By the work made in this thesis
the library has been extended to include an efficient Viterbi implementation
and an indexed posterior decoding implementation exploiting repetitions, as well
as a posterior decoding implementation that does not exploit repetitions.

As zipHMMlib is written in C++, the additions made in this thesis have also
been written in C++. The code is readily available\footnote{link til kode}.
\fxerror{URL here.} The build procedure has not changed, so for instructions on
how to build the project see \url{github.com/mailund/ziphmm}.

\section{Description of the Implementation}

In the original library the main class of the library was the
\texttt{Forwarder} class.  This class has been renamed to \texttt{HMMSuite}.
Like before the class is responsible for preprocessing sequences, reading and
writing these from and to the disk, and for executing the forward, backward,
Viterbi and posterior decoding algorithms.

For matrix multiplications a BLAS framework is used to make these as efficient
as possible.  For the max-times matrix multiplication and addition simple nested
for loops are used as BLAS does not support these operations.

The library supports reading in multiple sequences from a folder. In the
original library the sum of the probabilities for each sequence is returned by
the forward algorithm. It is not currently supported to read in multiple
sequences if either the forward or backward tables are requested and neither if
the Viterbi path or posterior decoding is requested.

\section{Usage}

In the following three sections the usage of the Viterbi algorithm, the
posterior decoding algorithm, and the indexed posterior decoding algorithm from
within C++ is described. Lastly the programs added to the library are
discussed.

\subsection{Viterbi}

In listing~\ref{lst:c++-example} an example of C++ program that uses zipHMMlib
to compute the Viterbi decoding can be found.

\begin{listing}
\begin{minted}[fontsize=\footnotesize]{C++}
#include "hmm_io.hpp"
#include "hmm_suite.hpp"

int main() {
    // Read input.
    zipHMM::HMMSuite h;
    size_t alphabet_size = 2;
    size_t min_num_of_evals = 1;
    size_t no_states = 2;
    h.read_seq("test.seq", alphabet_size, no_states, min_num_of_evals);

    // Save for future runs.
    h.write_to_directory("some_dir");

    // Read HMM.
    zipHMM::Matrix pi, A, B;
    zipHMM::read_HMM(pi, A, B, "test.hmm");

    // Run Viterbi.
    bool memory_save = false;
    std::vector<unsigned> viterbi_path;
    double probability = h.viterbi(pi, A, B, memory_save, viterbi_path);

    // Print result to stdout.
    std::cout << "Probability: " << probability << std::endl
              << "Path: ";
    for (std::vector<unsigned>::const_iterator it = viterbi_path.begin();
         it != viterbi_path.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    exit(0);
}
\end{minted}
\caption{Compute the Viterbi path using zipHMM.}
\label{lst:c++-example}
\end{listing}

The \texttt{HMMSuite.read\_seq(\dots)} reads a sequence from a file. The user
has to specify the alphabet size since the sequence may not contain all
symbols from the alphabet. Furthermore, the user specifies the number of states
in the model $N_{\min}$ that will be used later and the number of executions
$e$ of the Viterbi algorithm as discussed in
section~\ref{sec:compr-stopp-crit}.

If the compressed sequence will be reused later by another program it is saved
to the disk by \texttt{HMMSuite.write\_to\_directory(\dots)}. It can then be
loaded using \texttt{HMMSuite.read\_from\_directory(\dots)}.

\texttt{HMMSuite.read\_HMM(\dots)} simply reads an HMM specification from a
file.

\texttt{HMMSuite.viterbi(\dots)} runs the Viterbi algorithm. A boolean
\texttt{memory\_save} can be specified to choose whether to save memory or not
as discussed in section~\ref{sec:class-viterbi-algor}. If the parameter is not
specified, the algorithm defaults to using memory saving. If the parameter
\texttt{viterbi\_path} is provided, the algorithm will backtrack to obtain the
Viterbi path. If it is omitted only the probability of the most likely path is
computed.

\subsection{Posterior Decoding}

As described in section~\ref{sec:probl-expl-repet}, exploiting repetitions will
cannot speed up the execution of the posterior decoding algorithm. It might still
be faster, due matrix multiplications being faster than the classical
approach. The implementation finds a posterior decoding of the same length as
the compressed sequence. Hence, to find the posterior decoding of the original
observation sequence $Y_{1:T}$, compression should be disabled. This can be achieved by
specifying $e = 0$ when reading the sequence using
\texttt{HMMSuite.read\_seq(\dots)}.

The \texttt{HMMSuite.posterior\_decoding(\dots)} is a bit simpler than the
Viterbi method and takes as parameters the matrices $\pi, A$, and $B$ and a
vector in which the posterior decoding is saved.

\subsection{Indexed Posterior Decoding}

Compression can be enabled for the indexed posterior decoding. The
\texttt{HMMSuite::indexed\_posterior\_decoding(\dots)} takes as parameters the
matrices $\pi, A$, and $B$, the indices $i$ and $j$, and a reference to a vector
where the indexed posterior decoding is saved.

%%% Local Variables:
%%% mode: latex
%%% TeX-command-extra-options: "-shell-escape"
%%% TeX-master: "master"
%%% End:
